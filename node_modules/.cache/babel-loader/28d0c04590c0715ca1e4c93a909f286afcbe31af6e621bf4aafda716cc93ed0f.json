{"ast":null,"code":"/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\nfunction getAxisMap(element, {\n  x,\n  y\n}, {\n  xAxisID,\n  yAxisID\n}) {\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {\n      axisId: xAxisID\n    };\n  });\n  each(y, key => {\n    axisMap[key] = {\n      axisId: yAxisID\n    };\n  });\n  return axisMap;\n}\nconst cancelAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n  return window.cancelAnimationFrame;\n}();\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? {\n    value: scale.getPixelForValue(value),\n    transitionable: true\n  } : {\n    value: fallback\n  };\n}\nfunction updateBoxAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {\n        axisId: xScaleID\n      };\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {\n        axisId: xScaleID\n      };\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {\n        axisId: xScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {\n        axisId: yScaleID\n      };\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {\n        axisId: yScaleID\n      };\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {\n        axisId: yScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n}\nfunction updateLineAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    scaleID,\n    value\n  } = options;\n  const scale = scales[scaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {\n        axisId: scaleID\n      };\n      streaming[isHorizontal ? 'x2' : 'y2'] = {\n        axisId: scaleID\n      };\n    }\n    return isHorizontal ? {\n      top,\n      bottom\n    } : {\n      left,\n      right\n    };\n  }\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n    if (min.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.left = left;\n    }\n    if (max.transitionable) {\n      streaming.x2 = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.right = right;\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n    if (min.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.top = top;\n    }\n    if (max.transitionable) {\n      streaming.y2 = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n  return clip;\n}\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {\n    xScaleID,\n    yScaleID,\n    xValue,\n    yValue\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n    if (x.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    }\n  }\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n    if (y.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    }\n  }\n}\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n  BoxAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n  LineAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n  PointAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n      afterUpdate.call(this, _chart, args, options);\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n  if (plugin) {\n    const state = plugin._getState(chart);\n    return state && state.elements || [];\n  }\n  return [];\n}\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\nconst transitionKeys$1 = {\n  x: ['x', 'caretX'],\n  y: ['y', 'caretY']\n};\nfunction update$1(...args) {\n  const me = this;\n  const element = me.getActiveElements()[0];\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n  me.constructor.prototype.update.call(me, ...args);\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleOptions: {}\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction storeOriginalScaleOptions(chart) {\n  const {\n    originalScaleOptions\n  } = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDuration = 0,\n    maxDuration = Infinity,\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\nfunction panRealTimeScale(scale, delta, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n    streaming.zoomPlugin = plugin;\n  }\n}\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {\n    size: milliseconds,\n    steps\n  } = INTERVALS[unit];\n  let factor;\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n  return factor;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {\n      common,\n      size,\n      steps\n    } = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nconst datasetPropertyKeys = ['pointBackgroundColor', 'pointBorderColor', 'pointBorderWidth', 'pointRadius', 'pointRotation', 'pointStyle', 'pointHitRadius', 'pointHoverBackgroundColor', 'pointHoverBorderColor', 'pointHoverBorderWidth', 'pointHoverRadius', 'backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'radius', 'rotation'];\nfunction clean(scale) {\n  const {\n    chart,\n    id,\n    max\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n      count = i - start;\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\nfunction scroll(scale) {\n  const {\n    chart,\n    id,\n    $realtime: realtime\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {\n      data: elements = [],\n      dataset: element\n    } = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {\n      $realtime: realtime,\n      options\n    } = me;\n    const {\n      bounds,\n      offset,\n      ticks: ticksOpts\n    } = options;\n    const {\n      autoSkip,\n      source,\n      major: majorTicksOpts\n    } = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n        return resolveOption(me, 'frameRate');\n      });\n    }\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n      me._handleMargins();\n    }\n  }\n  draw(chartArea) {\n    const me = this;\n    const {\n      chart,\n      ctx\n    } = me;\n    const area = me.isHorizontal() ? {\n      left: chartArea.left,\n      top: 0,\n      right: chartArea.right,\n      bottom: chart.height\n    } : {\n      left: 0,\n      top: chartArea.top,\n      right: chart.width,\n      bottom: chartArea.bottom\n    };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const capacity = me._getLabelCapacity(min);\n    const {\n      time: timeOpts,\n      ticks: ticksOpts\n    } = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    time = first;\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n}\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\nvar version = \"2.0.0\";\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {\n  x: ['x', 'cp1x', 'cp2x'],\n  y: ['y', 'cp1y', 'cp2y']\n};\nfunction update(mode) {\n  const me = this;\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n      controller._setStyle = function (element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n  Chart.prototype.update.call(me, mode);\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {\n      render\n    };\n    const canvas = streaming.canvas = chart.canvas;\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n  afterInit(chart) {\n    chart.update = update;\n  },\n  beforeUpdate(chart) {\n    const {\n      scales,\n      elements\n    } = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, ({\n      type\n    }) => {\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n  beforeDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    if (mode === 'quiet') {\n      const {\n        controller,\n        $animations\n      } = meta;\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n  afterDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    const {\n      data: elements = [],\n      dataset: element,\n      controller\n    } = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n  beforeDatasetDraw(chart, args) {\n    const {\n      ctx,\n      chartArea,\n      width,\n      height\n    } = chart;\n    const {\n      xAxisID,\n      yAxisID,\n      controller\n    } = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n    clipArea(ctx, area);\n  },\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n  destroy(chart) {\n    const {\n      scales,\n      $streaming: streaming,\n      tooltip\n    } = chart;\n    const {\n      canvas,\n      mouseEventListener\n    } = streaming;\n    delete chart.update;\n    if (tooltip) {\n      delete tooltip.update;\n    }\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\nconst registerables = [StreamingPlugin, RealTimeScale];\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };","map":{"version":3,"names":["registry","TimeScale","defaults","DatasetController","Chart","valueOrDefault","each","requestAnimFrame","callback","noop","isFinite","clipArea","unclipArea","isNumber","_lookup","isArray","getRelativePosition","clamp","value","lower","upper","Math","min","max","resolveOption","scale","key","realtimeOpts","options","realtime","streamingOpts","chart","plugins","streaming","getAxisMap","element","x","y","xAxisID","yAxisID","axisMap","axisId","cancelAnimFrame","window","cancelAnimationFrame","startFrameRefreshTimer","context","func","frameRequestID","refresh","nextRefresh","now","Date","newFrameRate","frameDuration","newNextRefresh","call","stopFrameRefreshTimer","stopDataRefreshTimer","refreshTimerID","clearInterval","refreshInterval","startDataRefreshTimer","interval","setInterval","newInterval","isNaN","scaleValue","fallback","parse","getPixelForValue","transitionable","updateBoxAnnotation","scales","chartArea","xScaleID","yScaleID","xMin","xMax","yMin","yMax","xScale","yScale","top","left","bottom","right","$streaming","reverse","width","height","updateLineAnnotation","scaleID","isHorizontal","pixel","clip","x2","y2","updatePointAnnotation","xValue","yValue","initAnnotationPlugin","BoxAnnotation","getElement","LineAnnotation","PointAnnotation","resolveBoxAnnotationProperties","prototype","resolveElementProperties","resolveLineAnnotationProperties","resolvePointAnnotationProperties","properties","attachChart$1","plugin","annotationPlugin","afterUpdate","_chart","args","mode","animationOpts","animation","getElements","state","_getState","elements","detachChart$1","transitionKeys$1","update$1","me","getActiveElements","meta","getDatasetMeta","datasetIndex","constructor","update","chartStates","WeakMap","getState","get","originalScaleOptions","set","removeState","delete","storeOriginalScaleOptions","id","duration","delay","opt","zoomRealTimeScale","zoom","center","limits","axis","minDuration","maxDuration","Infinity","minDelay","maxDelay","newDuration","maxPercent","newDelay","panRealTimeScale","delta","getValueForPixel","resetRealTimeScaleOptions","realtimeOptions","original","initZoomPlugin","zoomFunctions","panFunctions","attachChart","zoomPlugin","resetZoom","transition","detachChart","INTERVALS","millisecond","common","size","steps","second","minute","hour","day","week","month","quarter","year","UNITS","Object","keys","determineStepSize","unit","capacity","range","milliseconds","factor","ceil","i","ilen","length","determineUnitForAutoTicks","minUnit","indexOf","Number","MAX_SAFE_INTEGER","determineMajorUnit","addTick","ticks","time","timestamps","lo","hi","timestamp","datasetPropertyKeys","clean","ttl","pause","start","count","removalRange","data","datasets","dataset","controller","point","getParsed","splice","datalabels","_active","item","index","labels","translate","animations","$animations","_from","_to","scroll","$realtime","tooltip","annotations","offset","head","_path","RealTimeScale","props","init","scaleOpts","opts","onRefresh","maxWidth","maxHeight","margins","bounds","ticksOpts","autoSkip","source","major","majorTicksOpts","majorEnabled","enabled","render","undefined","buildTicks","maxArray","minArray","defineProperty","shift","calculateLabelRotation","maxRotation","minRotation","fit","display","paddingLeft","paddingRight","_handleMargins","draw","ctx","area","_gridLineItems","_labelItems","destroy","_generate","adapter","_adapter","_getLabelCapacity","timeOpts","minor","stepSize","weekday","isoWeekday","majorTicksEnabled","hasWeekday","first","startOf","diff","Error","round","add","getDataTimestamps","sort","a","b","map","adapters","parser","displayFormats","describe","_scriptable","name","version","quiet","transitionKeys","_setStyle","_mode","active","lastMouseEvent","setTimeout","_eventHandler","StreamingPlugin","beforeInit","canvas","mouseEventListener","event","pos","type","native","addEventListener","afterInit","beforeUpdate","line","capBezierPoints","getPlugin","e","beforeDatasetUpdate","visible","updateElement","updateSharedOptions","afterDatasetUpdate","beforeDatasetDraw","getScaleForId","afterDatasetDraw","beforeEvent","removeEventListener","frameRate","descriptors","registerables"],"sources":["C:/Users/EL/Documents/GitHub/alivenft.github.io/node_modules/chartjs-plugin-streaming/dist/chartjs-plugin-streaming.esm.js"],"sourcesContent":["/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\nfunction getAxisMap(element, {x, y}, {xAxisID, yAxisID}) {\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {axisId: xAxisID};\n  });\n  each(y, key => {\n    axisMap[key] = {axisId: yAxisID};\n  });\n  return axisMap;\n}\nconst cancelAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n  return window.cancelAnimationFrame;\n}());\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ?\n    {value: scale.getPixelForValue(value), transitionable: true} :\n    {value: fallback};\n}\nfunction updateBoxAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {axisId: xScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {axisId: xScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {axisId: xScaleID, reverse: min.transitionable};\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {axisId: yScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {axisId: yScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {axisId: yScaleID, reverse: min.transitionable};\n    }\n  }\n}\nfunction updateLineAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {scaleID, value} = options;\n  const scale = scales[scaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {axisId: scaleID};\n      streaming[isHorizontal ? 'x2' : 'y2'] = {axisId: scaleID};\n    }\n    return isHorizontal ? {top, bottom} : {left, right};\n  }\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n    if (min.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    } else {\n      clip.left = left;\n    }\n    if (max.transitionable) {\n      streaming.x2 = {axisId: xScaleID};\n    } else {\n      clip.right = right;\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n    if (min.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    } else {\n      clip.top = top;\n    }\n    if (max.transitionable) {\n      streaming.y2 = {axisId: yScaleID};\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n  return clip;\n}\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {xScaleID, yScaleID, xValue, yValue} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n    if (x.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    }\n  }\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n    if (y.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    }\n  }\n}\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n  BoxAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n  LineAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n  PointAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n      afterUpdate.call(this, _chart, args, options);\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n  if (plugin) {\n    const state = plugin._getState(chart);\n    return state && state.elements || [];\n  }\n  return [];\n}\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {x: ['x', 'caretX'], y: ['y', 'caretY']};\nfunction update$1(...args) {\n  const me = this;\n  const element = me.getActiveElements()[0];\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {originalScaleOptions: {}};\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction storeOriginalScaleOptions(chart) {\n  const {originalScaleOptions} = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {chart, axis} = scale;\n  const {minDuration = 0, maxDuration = Infinity, minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\nfunction panRealTimeScale(scale, delta, limits) {\n  const {chart, axis} = scale;\n  const {minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n    streaming.zoomPlugin = plugin;\n  }\n}\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {size: milliseconds, steps} = INTERVALS[unit];\n  let factor;\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n  return factor;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {common, size, steps} = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nconst datasetPropertyKeys = [\n  'pointBackgroundColor',\n  'pointBorderColor',\n  'pointBorderWidth',\n  'pointRadius',\n  'pointRotation',\n  'pointStyle',\n  'pointHitRadius',\n  'pointHoverBackgroundColor',\n  'pointHoverBorderColor',\n  'pointHoverBorderWidth',\n  'pointHoverRadius',\n  'backgroundColor',\n  'borderColor',\n  'borderSkipped',\n  'borderWidth',\n  'hoverBackgroundColor',\n  'hoverBorderColor',\n  'hoverBorderWidth',\n  'hoverRadius',\n  'hitRadius',\n  'radius',\n  'rotation'\n];\nfunction clean(scale) {\n  const {chart, id, max} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n      count = i - start;\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\nfunction scroll(scale) {\n  const {chart, id, $realtime: realtime} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {data: elements = [], dataset: element} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {$realtime: realtime, options} = me;\n    const {bounds, offset, ticks: ticksOpts} = options;\n    const {autoSkip, source, major: majorTicksOpts} = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n        return resolveOption(me, 'frameRate');\n      });\n    }\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n      me._handleMargins();\n    }\n  }\n  draw(chartArea) {\n    const me = this;\n    const {chart, ctx} = me;\n    const area = me.isHorizontal() ?\n      {\n        left: chartArea.left,\n        top: 0,\n        right: chartArea.right,\n        bottom: chart.height\n      } : {\n        left: 0,\n        top: chartArea.top,\n        right: chart.width,\n        bottom: chartArea.bottom\n      };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const capacity = me._getLabelCapacity(min);\n    const {time: timeOpts, ticks: ticksOpts} = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    time = first;\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n}\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\n\nvar version = \"2.0.0\";\n\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {x: ['x', 'cp1x', 'cp2x'], y: ['y', 'cp1y', 'cp2y']};\nfunction update(mode) {\n  const me = this;\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n      controller._setStyle = function(element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n  Chart.prototype.update.call(me, mode);\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {render};\n    const canvas = streaming.canvas = chart.canvas;\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n  afterInit(chart) {\n    chart.update = update;\n  },\n  beforeUpdate(chart) {\n    const {scales, elements} = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, ({type}) => {\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n  beforeDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    if (mode === 'quiet') {\n      const {controller, $animations} = meta;\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n  afterDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    const {data: elements = [], dataset: element, controller} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n  beforeDatasetDraw(chart, args) {\n    const {ctx, chartArea, width, height} = chart;\n    const {xAxisID, yAxisID, controller} = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n    clipArea(ctx, area);\n  },\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n  destroy(chart) {\n    const {scales, $streaming: streaming, tooltip} = chart;\n    const {canvas, mouseEventListener} = streaming;\n    delete chart.update;\n    if (tooltip) {\n      delete tooltip.update;\n    }\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\n\nconst registerables = [StreamingPlugin, RealTimeScale];\n\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}